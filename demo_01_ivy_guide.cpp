#include "ivy_array/inc/ivy.h"
#include "ivy_array/inc/utils.h"

#include <iostream>
#include <vector>
#include <algorithm>
#include <stdlib.h>


// это вместо функции main()
void user_thread(){
	
// Часть 1: массив ivy
	// ivy - массив целых чисел.
	// Используются только числа от 0 до 99.
	// Массив не может быть пустым.
	
	
// Часть 2: инициализация ivy
	// массив A из 100 элементов с непредсказуемым содержанием.
	ivy A(100);
	
	// массив B из 25 элементов, все равны 60.
	ivy B(25, 60);
	
	// массив C из 80 случайных элементов.
	ivy C(80, -1);
	
	// инициализация {}-скобками
	ivy D = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 3, 4, 33};
	
	// инициализация копированием
	ivy E(C);
	
	// присвоение
	// (инвалидирует созданные ранее итераторы на массив D!)
	D = C;
	
	// инициализация итераторами [от, до)
	ivy G(C.begin(), C.end());

	
// Часть 3: добавление элементов
	// добавление элемента 42 в конец массива A.
	// (инвалидирует созданные ранее итераторы на массив A!)
	A.push_back(42);	
	
	// копия массива C в конец массива B.
	// (инвалидирует созданные ранее итераторы на массив B!)
	B.push_back(C);
	

// Часть 4: обращение к элементам массива
	int i = 4;
	A[i] = 88;
	std::cout << A[i] << '\n';
	
	// обращение через итератор
	auto it = A.end()-1;
	*it = 90;
	// итератор end() указывает на элемент,
	// следующий за последним.
	
	// обращение через цикл
	for (int i = 0; i < B.size(); i++){
		if (B[i] > 50)
			B[i] -= 30;
		else
			B[i] += 20;
	}
	
	// рбаотает также и range-based for loop
	for( auto el:B)
		std::cout << el << '\n';
	
	// Обратите внимвние!
	// нет ограничений по доступу в чужую память!
	for (int i = 0; i < 400; i++){
		A[i] = 34;
	}
	
	
// Часть 5: стандартные алгоритмы
	// кое-что работает, как минимум сортировка массива
	std::sort(D.begin(), D.end());
	
	
// Часть 6: //Допустимые операции с итератором:
	auto it1 = A.begin(); // получение итератора на начало
	auto it2 = A.end(); // и конец ivy массива
	auto it3(it1); // инициализация копированием
	
	++it1; // пред инкремент
	++it1; // пред декремент
	it1++; // пост инкремент
	it1--; // пост декремент
	it1 = it1 + 5; // продвижение вперед на целое число
	it1 = it1 - 2; // продвижение назад на целое число
	int v = *it1; // доступ к элементу массива через итератор
	
	int dist = it2 - it1; // расстояние между элементами;
	
	bool flag; // операции сравнения:
	flag = it1 == it2; // равны
	flag = it1 != it2; // не равны
	flag = it1 > it2;  // больше
	flag = it1 >= it2; // больше или равно
	flag = it1 < it2;  // меньше
	flag = it1 <= it2; // меньше или равно

}




